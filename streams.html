<!doctype html>
<html lang="en-US">
<meta charset=UTF-8>
<title>Streams with Promises</title>
<link rel=stylesheet href=http://www.whatwg.org/style/specification>
<link rel=icon href=//resources.whatwg.org/logo-dom.svg>

<div class="head">

<h1 class="head">Streams API (Promises version)</h1>

<dl>
 <dt>Participate:
 <dd>Send feedback to
  public-webapps@w3.org (<a href="http://lists.w3.org/Archives/Public/public-webapps/">archives</a>)

 <dt>Editor:
 <dd>Takeshi Yoshino, Google
</dl>

</div>

<h2 class="no-num no-toc" id="specabstract">Abstract</h3>

<p>This document proposes integration of <a href="https://github.com/domenic/promises-unwrapping/blob/master/README.md">Promises</a> and <a href="https://dvcs.w3.org/hg/streams-api/raw-file/tip/Overview.htm">Streams API</a>.

<h2 class="no-num no-toc" id="toc">Table of Contents</h2>

<!--toc-->

<h2>Interface <code title>Stream</code></h2>

<pre class="idl">
enum <dfn>StreamReadType</dfn> {
  &quot;&quot;,
  &quot;blob&quot;,
  &quot;arraybuffer&quot;,
  &quot;text&quot;
};

interface <dfn>StreamConsumeResult</dfn> {
  readonly attribute boolean eof;
  readonly any data;
  readonly unsigned long long size;
};

[<span title="dom-Stream">Constructor</span>(optional DOMString <var>type</var>)]
interface <dfn id="stream">Stream</dfn> {
  readonly attribute DOMString <span title="dom-Stream-type">type</span>;

  Promise <span title="dom-Stream-write">write</span>((DOMString or ArrayBufferView or Blob)? <var>data</var>);
  void <span title="dom-Stream-close">close</span>();

  attribute <span>StreamReadType</span> <span title="dom-Stream-readType">readType</span>;
  atrribute DOMString <span title="dom-Stream-readEncoding">readEncoding;

  Promise <span title="dom-Stream-read">read</span>(optional [Clamp] unsigned long long <var>size</var>);
  Promise <span title="dom-Stream-skip">skip</span>(optional [Clamp] unsigned long long <var>size</var>);
  Promise <span title="dom-Stream-pipe">pipe</span>((Stream or Stream[]) <var>destinations</var>, optional [Clamp] unsigned long long <var>size</var>);
};</pre>

<p>The
<dfn title="dom-Stream-type"><code>type</code></dfn>
attribute must return the MIME type of the stream.

<h3>Reading and writing</h3>

<p>To <dfn id="write-to-the-stream">write to the stream</dfn> (TBA). Note: success of write() doesn't guarantee that the written data has been read out successfully.

<p>To <dfn id="read-from-the-stream">read from the stream</dfn> (TBA). Written data is read on FIFO basis. Resource will be released as data is read.

<p>To <dfn id="write-close-the-stream">write close the stream</dfn> (TBA).

<h3>Constructor</h3>

<p>The <code>Stream</code> object has associated
<dfn>type</dfn>,
<dfn>write closed flag</dfn>,
<dfn>write pending flag</dfn> and
<dfn>read pending flag</dfn>.

<p>The <code>Stream</code> object represents a data sources for which the total size is unknown until EOF is reached. Using Promises, Streams provides read once access model. Data queued to a stream is read in FIFO order. Data pushed to a stream can be read out only once from it.

<dl class="domintro">
 <dt><code><var>stream</var> = new <span title="dom-Stream">Stream</span>()</code>
 <dd>
 <p>Returns a new <code>Stream</code> object.

 <dt><code><var>stream</var> = new <span title="dom-Stream">Stream</span>(type)</code>
 <dd>
 <p>Returns a new <code>Stream</code> object with its <span>type</span> set to the given value.
</dl>

<h3>The <code title>write()</code> method</h3>

<p>The <dfn title=dom-Stream-write><code>write(<var>data</var>)</code></dfn> method takes a <var>data</var>, and runs these steps:

<ol>
 <li>If has been neutered, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>write closed flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>write pending flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>Set <span>write pending flag</span>.
 <li>Let <var>writePromise</var> be a new promise.
 <li>Return the <span title=dom-Stream-read>write()</span> method with <var>writePromise</var>, but continue to process the steps in this algorithm.
 <li>Follow these rules, depending on <var>data</var>:
  <dl class="switch">
   <dt>a string
   <dd>Let <var>rawData</var> be the result of converting <var>data</var> to a (TBA)
   <dt><code>ArrayBufferView</code>
   <dd>Let <var>rawData</var> be the raw data represented by the <code>Blob</code> object.
   <dt><code>Blob</code>
   <dd>Let <var>rawData</var> be the data stored in the section of the buffer described by the <var>ArrayBuffer</var> object that the <code>ArrayBufferView</code> object references.
  </dl>
 <li><span title="write-to-the-stream">Write <var>rawData</var> to the stream</span>.
 <li>If any error has occurred during writing, neuter the stream, let <var>exception</var> be an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and run <code>Reject(<var>writePromise</var>, <var>exception</var>)</code> as specified in the promises spec and terminate these steps.
 <li>Unset <span>write pending flag</span> and run <code>Resolve(<var>writePromise</var>, <code>undefined</code>)</code> as specified in the promises spec. Implementations may delay this step if appropriate.
</ol>

<h3>The <code title>close()</code> method</h3>

<p>The <dfn title=dom-Stream-close><code>close(<var>data</var>)</code></dfn> method takes a <var>data</var>, and runs these steps:

<ol>
 <li>If has been neutered, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>write closed flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>write pending flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>Set <span>write closed flag</span>.
 <li><span title="write-close-the-stream">Write close the stream</span>.
 <li>If any error has occurred during write close alrogithm, neuter the stream and terminate these steps.
</ol>

<h3>The <code title>readType</code> attribute</h3>

<dl class=domintro>
 <dt><code><var>stream</var> . <span title=dom-Stream-readType>readType</span> [ = <var>value</var> ]</code>
 <dd>
  <p>Returns the read type.
  <p>Can be set to change the read type. Values are:
  the empty string (default),
  "<code>arraybuffer</code>",
  "<code>blob</code>" and
  "<code>text</code>".
</dl>

<p>The
<dfn title="dom-Stream-readType"><code>readType</code></dfn>
attribute must return its value. Initially its value must be the empty string.

<p>Setting the
<code title="dom-Stream-readType">readType</code>
attribute must set its value to the given value.

<h3>The <code title>readEncoding</code> attribute</h3>

<dl class=domintro>
 <dt><code><var>stream</var> . <span title=dom-Stream-readEncoding>readEncoding</span> [ = <var>value</var> ]</code>
 <dd>
  <p>Returns the read encoding.
  <p>Can be set to change the read encoding.
</dl>

<p>The
<dfn title="dom-Stream-readEncoding"><code>readEncoding</code></dfn>
attribute must return its value. Initially its value must be the empty string.

<p>Setting the
<code title="dom-Stream-readEncoding">readEncoding</code>
attribute must set its value to the given value.

<h3>The <code title>read()</code> method</h3>

<p>The <dfn title=dom-Stream-read><code>read(<var>size</var>)</code></dfn> method takes optionally a <var>size</var>, and runs these steps:

<ol>
 <li>If has been neutered, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>read pending flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <var>size</var> is specified but is 0, throw a "<code data-anolis-spec=dom>SyntaxError</code>" exception and terminate these steps.
 <li>Set <span>read pending flag</span>.
 <li>Let <var>readPromise</var> be a new promise.
 <li>Return the <span title=dom-Stream-read>read()</span> method with <var>readPromise</var>, but continue to process the steps in this algorithm.
 <li>If <var>size</var> is specified, <span title="read-from-the-stream">read data from the stream</span> until <var>size</var> bytes are read.
 <li>Otherwise, <span title="read-from-the-stream">read data from the stream</span> until any non-zero bytes are read.
 <li>If any error has occurred during reading, neuter the stream, let <var>exception</var> be an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and run <code>Reject(<var>readPromise</var>, <var>exception</var>)</code> as specified in the promises spec and terminate these steps.
 <li>Let <var>result</var> be a newly created Object that uses <span>StreamConsumeResult</span> interface.
 <li>If EOF is reached, set <var>eof</var> attribute of <var>result</var> to true.
 <li>Otherwise, set <var>eof</var> attribute of <var>result</var> set to false.
 <li>Set <var>data</var> attribute of <var>result</var> to the result of running these steps.
 <dl class="switch">
  <dt>If <code title="dom-Stream-readType">readType</code> is the emtpry string or "<code title>text</code>"
  <dd>
   <ol>
    <li>Let charset be utf-8.
    <li>If type is (TBA)
    <li>If readEncoding is not null, (TBA)
    <li>Let <var>result</var> be result of running decode on the read data using fallback encoding charset.
   </ol>
  <dt>If <code title="dom-Stream-readType">readType</code> is the emtpry string or "<code title>blob</code>"
  <dd>Let <var>result</var> be a blob created from the read data
  <dt>If <code title="dom-Stream-readType">readType</code> is the emtpry string or "<code title>arraybuffer</code>"
  <dd>Let <var>result</var> be an array buffer created from the read data
 </dl>
 <li>Unset <span>read pending flag</span> and run <code>Resolve(<var>readPromise</var>, <var>result</var>)</code> as specified in the promises spec.
</ol>

<h3>The <code title>skip()</code> method</h3>

<p>The <dfn title=dom-Stream-skip><code>skip(<var>size</var>)</code></dfn> method takes optionally a <var>size</var>, and runs these steps:

<ol>
 <li>If has been neutered, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>read pending flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <var>size</var> is specified but is 0, throw a "<code data-anolis-spec=dom>SyntaxError</code>" exception and terminate these steps.
 <li>Set <span>read pending flag</span>.
 <li>Let <var>readPromise</var> be a new promise.
 <li>Return the <span title=dom-Stream-skip>skip()</span> method with <var>readPromise</var>, but continue to process the steps in this algorithm.
 <li>If <var>size</var> is specified, <span title="read-from-the-stream">read data from the stream</span> until <var>size</var> bytes are read.
 <li>Otherwise, <span title="read-from-the-stream">read data from the stream</span> until any non-zero bytes are read.
 <li>If any error has occurred during reading, neuter the stream, let <var>exception</var> be an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and run <code>Reject(<var>readPromise</var>, <var>exception</var>)</code> as specified in the promises spec and terminate these steps.
 <li>Let <var>result</var> be a newly created Object that uses <span>StreamConsumeResult</span> interface.
 <li>If EOF is reached, set <var>eof</var> attribute of <var>result</var> to true.
 <li>Otherwise, set <var>eof</var> attribute of <var>result</var> set to false.
 <li>Set <var>size</var> attribute of <var>result</var> to the size of the read data.
 <li>Unset <span>read pending flag</span> and run <code>Resolve(readPromise, result)</code> as specified in the promises spec.
</ol>

<h3>The <code title>pipe()</code> method</h3>

<p>The <dfn title=dom-Stream-pipe><code>pipe(<var>destinations</var>, <var>size</var>)</code></dfn> method takes a <var>destinations</var> and optionally a <var>size</var>, and runs these steps:

<ol>
 <li>If has been neutered, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <span>read pending flag</span> is set, throw an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and terminate these steps.
 <li>If <var>size</var> is specified but is 0, throw a "<code data-anolis-spec=dom>SyntaxError</code>" exception and terminate these steps.
 <li>If <var>destinations</var> is a string, let <var>destinations</var> instead be an array consisting of just that string.
 <li>Set <span>read pending flag</span>.
 <li>Let <var>readPromise</var> be a new promise.
 <li>Return the <span title=dom-Stream-pipe>pipe()</span> method with <var>readPromise</var>, but continue to process the steps in this algorithm.
 <li>If <var>size</var> is specified, <span title="read-from-the-stream">read data from the stream</span> until <var>size</var> bytes are read.
 <li>Otherwise, <span title="read-from-the-stream">read data from the stream</span> until EOF is reached.
 <li>As read data becomes available, <span title="write-to-the-stream">write newly read data to <var>destinations</var></span>.
 <li>If any error has occurred during reading or writing to <var>destinations</var>, neuter the stream, let <var>exception</var> be an "<code data-anolis-spec=dom>InvalidStateError</code>" exception and run <code>Reject(<var>readPromise</var>, <var>exception</var>)</code> as specified in the promises spec and terminate these steps.
 <li>Once read is completed and write are both completed for all destination streams, run the following algorithm:
 <ol>
   <li>Let <var>result</var> be a newly created Object that uses <span>StreamConsumeResult</span> interface.
   <li>If EOF is reached, set <var>eof</var> attribute of <var>result</var> to true.
   <li>Otherwise, set <var>eof</var> attribute of <var>result</var> set to false.
   <li>Set <var>size</var> attribute of <var>result</var> to the total size of the read data.
   <li>Unset <span>read pending flag</span> and run <code>Resolve(<var>readPromise</var>, <var>result</var>)</code> as specified in the promises spec.
 </ol>
</ol>

<h2 class=no-num>Acknowledgments</h2>

<p>Thanks to

(TBA mainly from http://lists.w3.org/Archives/Public/public-webapps/2013AprJun/0706.html)

for their useful comments.
